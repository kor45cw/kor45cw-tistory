# Extension

## 서브스크립트

* 인덱스를 통해 값을 설정하거나 가져올 수 있다
* 한타입에 여러개의 서브스크립트 정의 가능
* 다른 타입을 인덱스로 갖는 여러개의 서브스크립트를 중복 정의 가능

### 문법

```swift
subscript(index: Int) -> Int {
    get { 적절한 subscript 결과값 반환 }
    set { 적절한 설정 역할 수행 }
}
```

## 상속

### 2단계 초기화

* 클래스의 인스턴스는 1단계 초기화를 마치기 전까지는 유효하지 않습니다.
* 프로퍼티는 읽기만 가능하며, 메소드는 호출될 수 있을 뿐
* 1단계
  * 클래스가 지정 또는 편의\(convenience\) 이니셜라이져를 호출
  * 그 클래스의 새로운 인스턴스를 위한 메모리가 할당, 메모리는 아직 초기화 전
  * 지정 이니셜라이저는 클래스에 정의된 모든 저장 프로퍼티에 값이 있는지 확인. 현재 클래스 부분까지의 저장 프로퍼티를 위한 메모리는 이제 초기화 
  * 지정 이니셜라이저는 부모클래스의 이니셜라이저가 같은 동작을 행할 수 있도록 초기화를 양도
  * 부모 클래스는 상속 체인을 따라 최상위에 도달할 때까지 이 작업을 반복
* 2단계
  * 최상위 클래스로부터 최하위 클래스까지 상속체인을 따라 내려오면서 지정 이니셜라이저들이 인스턴스를 각각 사용자 정의하게 됩니다. 이 단계에서는 self를 통해 프로퍼티 값을 수정할 수 있고, 인스턴스 메서드를 호출하는 등의 작업을 진행할 수 있다
  * 마지막으로 각각의 편의 이니셜라이저를 통해 self를 통한 사용자정의 작업을 진행할 수 있다

### 이니셜라이저 상속 및 재정의

* 기본적으로 부모 클래스의 이니셜라이저를 상속 받지않는다
* 자식 클래스에서 부모클래스의 편의 이니셜라이저는 절대 호출할 수 없다
* 이니셜라이저 자동 상속
  * 규칙 1: 자식클래스에서 별도의 지정 이니셜라이저를 구현하지 않는다면, 부모클래스의 지정 이니셜라이저가 자동으로 상속됩니다
  * 규칙 2: 규칙1에 따라 자동 상속 받는 경우 또는 부모 클래스의 지정 이니셜라이저를 모두 재정의하여 부모 클래스와 동일한 지정 이니셜라이저를 모두 사용할 수 있는 상황이라면, 부모클래스의 편의 이니셜라이저가 모두 자동으로 상속된다

### 요구 이니셜라이져 \(required\)

* 이 클래스를 상속 받는 자식 클래스는 반드시 해당 이니셜라이저를 구현해 주어야한다.

## 타입캐스팅

* 묵시적 형변환이 가능하지 않다
* 스위프트의 타입캐스팅
  * 인스턴스의 타입을 확인하거나 자신을 다른 타입의 인스턴스인양 행세할 수 있는 방법으로 사용할 수 있습니다.
* is : 데이터 타입 확인

### 다운캐스팅

* as를 통해 원하는 타입으로 변경하면 됩니다

## 프로토콜

* 특정 역할을 하기 위한 메소드, 프로퍼티, 기타 요구사항 등의 청사진을 정의
* 정의를 하고 제시할 뿐 스스로 기능을 구현하지는 않습니다
* 인스턴스 내부의 값을 변경할 경우 mutating 선언을 추가
* 이니셜라이져도 명세에 추가 할 수 있음
* 프로토콜 역시 상속을 받을 수 있다
* 클래스 전용 프로토콜을 만들고 싶으면, class를 상속받는 프로토콜을 생성
* 여러 프로토콜 준수하는것을 확인할 때 : SomeProtocol & AnyProtocol
* 선택적 요구를 할 경우 @objc & optional 를 추가해야한다: 클래스에서만 채택가능
* 위임 \(delegateion\)
  * 클래스나 구조체가 자신의 책임이나 임무를 다른 타입의 인스턴스에게 위임하는 디자인 패턴
  * 비동기처리나, 사용자의 특정행동에 반응하기 위함

## 익스텐션

* 기능을 추가하려는 타입을 구현한 소스코드를 알지 못하거나 볼 수 없다해도, 타입만 안다면 그 타입의 기능을 확장할 수 있음
* 추가할 수 있는 기능
  * 연산타입 프로퍼티 / 연산 인스턴스 ㅡㅍ로퍼티
  * 타입 메서드 / 인스턴스 메서드
  * 이니셜라이져
  * 서브스크립트
  * 중첩 타입
  * 특정 프로토콜 준수하도록 기능 추가
* 새로운 기능추가는 되지만, 기존에 존재하는 기능의 재정의는 불가능

## 제네릭

* 제네릭의 표시: &lt;&gt;    

```swift
prefix func **<T: BinaryInteger> (value: T) -> T {
    return value * value
}
```

### 타입 제약

* 클래스 타입 또는 프로토콜만 줄 수 있다

```swift
Dictionary<Key: Hashable, Value>
```

* key는 hashable 프로토콜을 따라는 타입만 사용가능

### 프로토콜의 연관타입 \(associatedtype\)

* 타입이 그 어떤것이어도 상관없지만, 하나의 타입임은 분명하다 라는 의미

