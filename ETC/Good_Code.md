# Good Code

- 코드를 완전히 이해 한다는 것
	- 코드를 자유롭게 수정
	- 버그를 짚어내는 것이 가능
	- 수정된 내용이 다른부분의 코드와 어떻게 상호작용하는지


## 네이밍
- 	적절한 이름을 붙일 수 있다는 것
	-  해당 요소가 바르게 이해되고 바르게 설계되어 있다는 뜻

- 효과적인 네이밍 작성
	- 이름은 효과와 목적을 설명하도록 한다.
	- 이름은 발음 가능한 것으로 한다.
	- 이름은 검색 가능하도록 한다.

- 네이밍을 잘했는 지 확인하려면?
	- 설명 -> 이름 -> 설명 순으로 한 바퀴 돌았을 때 원래대로 돌아오면 좋은 이름

- 이름에 정보를 담아내는 방법
	1. 보편적인 단어를 피하고 구체적인 단어를 선택한다.
	2. 시간의 양이나 바이트의 수 같이 측정치를 포함한다면, 단위를 포함시킨다.
	3. 위험한 요소 표현

- 나중에 잘못 이해했을 때 심각한 버그를 만들 가능성 있는 것들을 표현하는 게 좋다.
	- 패스워드가 암호화 안되있다면 : password => plainTextPassword
	- URL Encoded 데이터라면 : data => dataURLEnc
	- 이스케이프 처리가 되어야 한다면 : comment => unescapedComment

- 이름은 얼마나 길어야 할까?
	- 좁은 범위에서는 짧은 이름이 괜찮다. 좁은 범위에서만 사용되는 변수의 이름에 많은 정보를 담을 필요가 없기 때문이다. 
	- 약어와 축약형을 사용하는 것은 특정 프로젝트에 국한된 의미를 가지기 때문에 좋은 생각이 아니다. 


##코드의 미학
- 미학적으로 보기 좋은 코드가 사용하기 더 편리하다는 사실은 명백하다.

- 일관성과 간결성을 위해서 줄바꿈을 재정렬
- 불규칙적으로 정의된 로직은 메소드를 활용하여 정렬
- 선언문을 블록으로 구성
- 추상화 수준 정리하기
	- 코드를 정리할 때는 높은 수준의 추상화 개념과 낮은 수준의 추상화 개념을 분리하도록 한다. 
	- 추상화 단계는 상하가 아니라 기능의 복잡도에 따라 여러 계층으로 분리한다.

- 논리 단순화
	- 조건, 루프, 흐름을 통제하는 선언문은 코드를 복잡하게 만드는 원인이다. 
	- 코드를 읽을 때 다시 되돌아가서 코드를 읽지 않아도 되게끔 만들어야 한다.

- 조건문에서 인수의 순서
	- 인수의 왼쪽은 질문을 받는 표현을 정의하고, 오른쪽에는 비교대상을 두는 것이 통계적으로 가독성이 더 좋다. 
	- 이러한 가이드 라인은 영어 어순과 일치한다.

- if/else 블록의 순서
	- if/else를 사용하는 경우 부정이 아닌 긍정을 먼저 다루는 게 좋다. 
	- 첫번째 블록을 생각할 때 한번 부정한 값을 생각해야 함으로 긍정부터 다루는 게 이해하기 쉽다.

- 중첩을 최소화하기
	- 코드의 중첩이 심할 수록 코드를 읽는 사람의 마음속에 존재하는 정신적 스택에 추가적인 조건이 입력된다. 
	- 중첩을 제거하려면 함수 중간에 반환하기를 하여 제거할 수 있다.


## 작은 것이 아름답다
- 작은 소프트웨어는 단순하고 다루기 쉬우며 큰 소프트웨어보다 훨씬 뛰어나다.

- 장점
	- 이해가 쉽다.
	- 수정이 쉽다.
	- 다른 소프트웨어와 조합하기 쉽다.

- 큰 소프트웨어 단점
	- 복잡하고 코드를 이해하기 어렵다.
	- 예측하지 못하고 사태에 대응하기 힘들다.


- 주어진 함수가 코드 블록을 보고, 스스로에게 질문하라 상위수준에서 본 이 코드의 목적은 무엇인가?
	- 코드의 모든 줄에 질문을 던져라 이 코드는 직접적으로 목적을 위해서 존재하는 가? 
	- 혹은 목적을 위해서 필요하긴 하지만 목적 자체와 직접적으로 상관없는 하위문제를 해결하는가?
	- 만약 상당히 원래의 목적과 직접적으로 관련되지 않은 하위문제를 해결하는 코드 분량이 많으면, 이를 추출해서 별도의 함수로 만든다.

- 루프의 내부에 있는 코드는 대부분 주요 목적과 직접 상관없는 하위문제를 다룬다.


- 기존의 인터페이스를 단순화하기
	- 라이브러리가 깔끔한 인터페이스를 제공하면 누구나 좋아한다. 
	- 하지만 자신이 사용하는 인터페이스가 깔끔하지 않다면, 깔끔한 덮개(Wrapper)로 보완할 수 있다.


## 테스트 코드
- 테스트 코드가 읽기 쉬워야 한다는 점은 테스트와 상관없는 실제 코드와 마찬가지로 중요하다. 
- 테스트 코드가 읽기 쉬우면, 사용자는 실제 코드가 어떻게 동작하는 지 그만큼 더 쉽게 이해할 수 있다.


### 명세 기반 테스트 기법 종류
- 테스트 기법을 정확히 알고 있어야 원하는 테스트와 테스트 코드의 목적을 명확히 할 수 있다. 
- 테스트 코드에는 테스트 기법 하나씩 사용하여 읽기 쉬운 코드를 만들도록 해야 한다.

1. 동등분할
	- 테스트 대상 데이터의 구간을 일정 간격으로 분할하여 케이스를 구성한다. 보통 데이터의 구간에 중간값을 대표값으로 사용한다.

2. 경계값 분석
	- 분기 또는 반복 구문의 경계 값을 기준으로 케이스를 구성한다. min, min+, normal, max-, max 다섯 경우의 케이스로 구성한다.

3. 결정 테이블
	- 조건(입력 값)과 행위(결과 값)를 테이블로 구성하여 케이스 및 절차를 구성한다. 프로세스 수행 중 요구되는 결정 또는 조건과 프로세스와 관련된 모든 동작을 기술한다.

4. 조합
	- 테스트하는 데 필요한 값이 다른 파라미터의 값과 최소한 한 번씩은 조합을하여 케이스를 구성한다. 대부분의 결함이 두 개 요소의 상호작용에 기인한다는 것에 착안하여, 두 개 요소의 모든 조합을 다룬다.

5. 상태전이
	- 시스템의 각 상태를 중심으로 케이스를 도출하고 전이 상태를 절차로 구성한다. 객체의 상태를 구분하고 이벤트에 의해 어느 한 상태에서 다른 상태로 전이되는 경우의 수를 테스트 케이스로 구성한다. 상태 머신을 사용하는 UI 컴포넌트 테스트 시 유용하다.


##함수형 프로그래밍
- 프로젝트를 운영하면서 기능이 추가되면 코드가 복잡해지지 않게 해야 한다. 
- 복잡성을 다스리는 비결은 코드베이스의 크기가 커질수록 복잡성이 증가하지 않도록 붙잡아 두는 것이다. 
- 바로 여기서 함수형 프로그래밍이 요긴하게 쓰인다.

###함수형 프로그래밍이란?
- 함수형 프로그래밍은 추상화 단위를 함수로 한다. 
- 함수들을 조립해서 고수준의 동작을 구현한다. 
- 자료구조를 새로 만들어 어떤 요건을 충족시키는 게 아니라, 배열/객체/문자열 등의 흔한 자료구조를 이용해 문제를 해결한다.


- 함수형 프로그래밍에서는 관찰할 수 있는 상태 변화를 최소화하려고 애쓴다. 
- 따라서 함수형 원칙을 고수하는 시스템에 새로운 기능을 추가할 때는 새로운 함수가 지역화되고 비파괴적인 데이터 전이 과정에서 어떻게 동작할 것인지를 파악하는 것이 핵심이다.

- 함수형 사고방식은 문제의 해결 방법을 동사(함수)들로 구성(조합)하는 것.

- 응용형 함수를 통해 다형성 만들기
	- 응용형 함수는 인자로 받은 함수가 알고 있는 인자를 해당 함수에게 평가받아 로직을 완성해나가는 것을 말한다. 
	- map, filter 와 같은 함수가 응용형 함수라고 한다. 
	- 어떠한 데이터 형태인지 관심이 분리가 되고 다형성을 사용할 수 있기 때문에 재사용성이 높아진다.

- 값 대신 함수를 사용하라
	- 우선 가장 간단한 함수인 repeat부터 살펴보자. 
	- repeat는 횟수와 값을 받아서 중복된 값을 횟수만큼 갖는 배열을 만드는 함수이다.
	- 독립적으로 동작하는 repeat를 구현하는 것도 괜찮지만 반복성이라는 일반성을 가지도록 repeat를 구현할 수 있다면 더 좋을 것이다. 즉, 어떤 숫자만큼 값을 반복하는 것도 괜찮지만 어떤 동작을 특정 횟수만큼 반복한다면 더 좋다.

- 명령형과 함수형 비교하기
	- 명령형 프로그램은 작업 수행에 필요한 전 단계를 노출하여 흐름이나 경로를 아주 자세히 서술한다. 
	- 보통 작업을 수행하는 단계는 루프와 분기문, 구문마다 값이 바뀌는 변수들로 빼곡히 들어찬다.
	- 반면, 선언적 프로그래밍, 특히 함수형 프로그래밍은 독립적인 블랙박스 연산들이 단순하게, 즉 최소한의 제어 구조를 통해 연결되어 추상화 수준이 높다. 
	- 실제로 함수형 프로그램은 데이터와 제어 흐름 자체를 고수준 컴포넌트 사이의 단순한 연결로 취급한다.


- 추상화 도구 클로저
	- 바인딩은 자바스크립트의 이름에 값을 할당하는 행위를 가르킨다. 
	- 변수 할당, 함수 인자 사용, this 전달, 프로퍼티 할당 등의 과정에 해당한다.
	- 클로저는 나중에 사용할 목적으로 정의된 스코프에 포함된 외부 바인딩을 캡쳐하는 함수다. 
	- 클로저는 비공개 접근을 제공할 뿐만 아니라 추상화 기법도 제공한다. 
	- 예를 들어 클로저를 이용해서 생성 시에 캡쳐되는 어떤 설정에 따라 다른 함수를 만들 수 있다.

- 커링
	- 각각의 논리적 인자에 대응하는 새로운 함수를 반환하는 함수를 커리함수라고 한다.